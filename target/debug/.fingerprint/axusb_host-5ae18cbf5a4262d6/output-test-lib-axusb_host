{"$message_type":"diagnostic","message":"associated type in `impl` without body","code":null,"level":"error","spans":[{"file_name":"src/host/controllers/mod.rs","byte_start":1643,"byte_end":1662,"line_start":64,"line_end":64,"column_start":5,"column_end":24,"is_primary":true,"text":[{"text":"    type InterruptPipe;","highlight_start":5,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"provide a definition for the type","code":null,"level":"help","spans":[{"file_name":"src/host/controllers/mod.rs","byte_start":1661,"byte_end":1662,"line_start":64,"line_end":64,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"    type InterruptPipe;","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":" = <type>;","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: associated type in `impl` without body\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/host/controllers/mod.rs:64:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m64\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    type InterruptPipe;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: provide a definition for the type: `= <type>;`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type in `impl` without body","code":null,"level":"error","spans":[{"file_name":"src/host/controllers/mod.rs","byte_start":1668,"byte_end":1686,"line_start":66,"line_end":66,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    type DeviceDetect;","highlight_start":5,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"provide a definition for the type","code":null,"level":"help","spans":[{"file_name":"src/host/controllers/mod.rs","byte_start":1685,"byte_end":1686,"line_start":66,"line_end":66,"column_start":22,"column_end":23,"is_primary":true,"text":[{"text":"    type DeviceDetect;","highlight_start":22,"highlight_end":23}],"label":null,"suggested_replacement":" = <type>;","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: associated type in `impl` without body\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/host/controllers/mod.rs:66:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    type DeviceDetect;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: provide a definition for the type: `= <type>;`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the type parameter `O` is not constrained by the impl trait, self type, or predicates","code":{"code":"E0207","explanation":"A type, const or lifetime parameter that is specified for `impl` is not\nconstrained.\n\nErroneous code example:\n\n```compile_fail,E0207\nstruct Foo;\n\nimpl<T: Default> Foo {\n    // error: the type parameter `T` is not constrained by the impl trait, self\n    // type, or predicates [E0207]\n    fn get(&self) -> T {\n        <T as Default>::default()\n    }\n}\n```\n\nAny type or const parameter of an `impl` must meet at least one of the\nfollowing criteria:\n\n - it appears in the _implementing type_ of the impl, e.g. `impl<T> Foo<T>`\n - for a trait impl, it appears in the _implemented trait_, e.g.\n   `impl<T> SomeTrait<T> for Foo`\n - it is bound as an associated type, e.g. `impl<T, U> SomeTrait for T\n   where T: AnotherTrait<AssocType=U>`\n\nAny unconstrained lifetime parameter of an `impl` is not supported if the\nlifetime parameter is used by an associated type.\n\n### Error example 1\n\nSuppose we have a struct `Foo` and we would like to define some methods for it.\nThe previous code example has a definition which leads to a compiler error:\n\nThe problem is that the parameter `T` does not appear in the implementing type\n(`Foo`) of the impl. In this case, we can fix the error by moving the type\nparameter from the `impl` to the method `get`:\n\n```\nstruct Foo;\n\n// Move the type parameter from the impl to the method\nimpl Foo {\n    fn get<T: Default>(&self) -> T {\n        <T as Default>::default()\n    }\n}\n```\n\n### Error example 2\n\nAs another example, suppose we have a `Maker` trait and want to establish a\ntype `FooMaker` that makes `Foo`s:\n\n```compile_fail,E0207\ntrait Maker {\n    type Item;\n    fn make(&mut self) -> Self::Item;\n}\n\nstruct Foo<T> {\n    foo: T\n}\n\nstruct FooMaker;\n\nimpl<T: Default> Maker for FooMaker {\n// error: the type parameter `T` is not constrained by the impl trait, self\n// type, or predicates [E0207]\n    type Item = Foo<T>;\n\n    fn make(&mut self) -> Foo<T> {\n        Foo { foo: <T as Default>::default() }\n    }\n}\n```\n\nThis fails to compile because `T` does not appear in the trait or in the\nimplementing type.\n\nOne way to work around this is to introduce a phantom type parameter into\n`FooMaker`, like so:\n\n```\nuse std::marker::PhantomData;\n\ntrait Maker {\n    type Item;\n    fn make(&mut self) -> Self::Item;\n}\n\nstruct Foo<T> {\n    foo: T\n}\n\n// Add a type parameter to `FooMaker`\nstruct FooMaker<T> {\n    phantom: PhantomData<T>,\n}\n\nimpl<T: Default> Maker for FooMaker<T> {\n    type Item = Foo<T>;\n\n    fn make(&mut self) -> Foo<T> {\n        Foo {\n            foo: <T as Default>::default(),\n        }\n    }\n}\n```\n\nAnother way is to do away with the associated type in `Maker` and use an input\ntype parameter instead:\n\n```\n// Use a type parameter instead of an associated type here\ntrait Maker<Item> {\n    fn make(&mut self) -> Item;\n}\n\nstruct Foo<T> {\n    foo: T\n}\n\nstruct FooMaker;\n\nimpl<T: Default> Maker<Foo<T>> for FooMaker {\n    fn make(&mut self) -> Foo<T> {\n        Foo { foo: <T as Default>::default() }\n    }\n}\n```\n\n### Error example 3\n\nSuppose we have a struct `Foo` and we would like to define some methods for it.\nThe following code example has a definition which leads to a compiler error:\n\n```compile_fail,E0207\nstruct Foo;\n\nimpl<const T: i32> Foo {\n    // error: the const parameter `T` is not constrained by the impl trait, self\n    // type, or predicates [E0207]\n    fn get(&self) -> i32 {\n        i32::default()\n    }\n}\n```\n\nThe problem is that the const parameter `T` does not appear in the implementing\ntype (`Foo`) of the impl. In this case, we can fix the error by moving the type\nparameter from the `impl` to the method `get`:\n\n\n```\nstruct Foo;\n\n// Move the const parameter from the impl to the method\nimpl Foo {\n    fn get<const T: i32>(&self) -> i32 {\n        i32::default()\n    }\n}\n```\n\n### Error example 4\n\nSuppose we have a struct `Foo` and a struct `Bar` that uses lifetime `'a`. We\nwould like to implement trait `Contains` for `Foo`. The trait `Contains` have\nthe associated type `B`. The following code example has a definition which\nleads to a compiler error:\n\n```compile_fail,E0207\nstruct Foo;\nstruct Bar<'a>;\n\ntrait Contains {\n    type B;\n\n    fn get(&self) -> i32;\n}\n\nimpl<'a> Contains for Foo {\n    type B = Bar<'a>;\n\n    // error: the lifetime parameter `'a` is not constrained by the impl trait,\n    // self type, or predicates [E0207]\n    fn get(&self) -> i32 {\n        i32::default()\n    }\n}\n```\n\nPlease note that unconstrained lifetime parameters are not supported if they are\nbeing used by an associated type.\n\n### Additional information\n\nFor more information, please see [RFC 447].\n\n[RFC 447]: https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md\n"},"level":"error","spans":[{"file_name":"src/host/controllers/mod.rs","byte_start":1522,"byte_end":1523,"line_start":59,"line_end":59,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"impl<T, O> cotton_usb_host::host_controller::HostController for T","highlight_start":9,"highlight_end":10}],"label":"unconstrained type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0207]\u001b[0m\u001b[0m\u001b[1m: the type parameter `O` is not constrained by the impl trait, self type, or predicates\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/host/controllers/mod.rs:59:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<T, O> cotton_usb_host::host_controller::HostController for T\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munconstrained type parameter\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)","code":{"code":"E0210","explanation":"This error indicates a violation of one of Rust's orphan rules for trait\nimplementations. The rule concerns the use of type parameters in an\nimplementation of a foreign trait (a trait defined in another crate), and\nstates that type parameters must be \"covered\" by a local type.\n\nWhen implementing a foreign trait for a foreign type,\nthe trait must have one or more type parameters.\nA type local to your crate must appear before any use of any type parameters.\n\nTo understand what this means, it is perhaps easier to consider a few examples.\n\nIf `ForeignTrait` is a trait defined in some external crate `foo`, then the\nfollowing trait `impl` is an error:\n\n```compile_fail,E0210\n# #[cfg(for_demonstration_only)]\nextern crate foo;\n# #[cfg(for_demonstration_only)]\nuse foo::ForeignTrait;\n# use std::panic::UnwindSafe as ForeignTrait;\n\nimpl<T> ForeignTrait for T { } // error\n# fn main() {}\n```\n\nTo work around this, it can be covered with a local type, `MyType`:\n\n```\n# use std::panic::UnwindSafe as ForeignTrait;\nstruct MyType<T>(T);\nimpl<T> ForeignTrait for MyType<T> { } // Ok\n```\n\nPlease note that a type alias is not sufficient.\n\nFor another example of an error, suppose there's another trait defined in `foo`\nnamed `ForeignTrait2` that takes two type parameters. Then this `impl` results\nin the same rule violation:\n\n```ignore (cannot-doctest-multicrate-project)\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```\n\nThe reason for this is that there are two appearances of type parameter `T` in\nthe `impl` header, both as parameters for `ForeignTrait2`. The first appearance\nis uncovered, and so runs afoul of the orphan rule.\n\nConsider one more example:\n\n```ignore (cannot-doctest-multicrate-project)\nimpl<T> ForeignTrait2<MyType<T>, T> for MyType2 { } // Ok\n```\n\nThis only differs from the previous `impl` in that the parameters `T` and\n`MyType<T>` for `ForeignTrait2` have been swapped. This example does *not*\nviolate the orphan rule; it is permitted.\n\nTo see why that last example was allowed, you need to understand the general\nrule. Unfortunately this rule is a bit tricky to state. Consider an `impl`:\n\n```ignore (only-for-syntax-highlight)\nimpl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n```\n\nwhere `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\nare types. One of the types `T0, ..., Tn` must be a local type (this is another\norphan rule, see the explanation for E0117).\n\nBoth of the following must be true:\n1. At least one of the types `T0..=Tn` must be a local type.\nLet `Ti` be the first such type.\n2. No uncovered type parameters `P1..=Pm` may appear in `T0..Ti`\n(excluding `Ti`).\n\nFor information on the design of the orphan rules,\nsee [RFC 2451] and [RFC 1023].\n\n[RFC 2451]: https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n"},"level":"error","spans":[{"file_name":"src/host/controllers/mod.rs","byte_start":1519,"byte_end":1520,"line_start":59,"line_end":59,"column_start":6,"column_end":7,"is_primary":true,"text":[{"text":"impl<T, O> cotton_usb_host::host_controller::HostController for T","highlight_start":6,"highlight_end":7}],"label":"type parameter `T` must be used as the type parameter for some local type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"implementing a foreign trait is only possible if at least one of the types for which it is implemented is local","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"only traits defined in the current crate can be implemented for a type parameter","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0210]\u001b[0m\u001b[0m\u001b[1m: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/host/controllers/mod.rs:59:6\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<T, O> cotton_usb_host::host_controller::HostController for T\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mtype parameter `T` must be used as the type parameter for some local type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: only traits defined in the current crate can be implemented for a type parameter\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`()` is not a future","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/host/controllers/mod.rs","byte_start":2036,"byte_end":2121,"line_start":82,"line_end":82,"column_start":10,"column_end":95,"is_primary":true,"text":[{"text":"    ) -> impl core::future::Future<Output = Result<usize, cotton_usb_host::usb_bus::UsbError>> {","highlight_start":10,"highlight_end":95}],"label":"`()` is not a future","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/host/controllers/mod.rs","byte_start":2036,"byte_end":2121,"line_start":82,"line_end":82,"column_start":10,"column_end":95,"is_primary":false,"text":[{"text":"    ) -> impl core::future::Future<Output = Result<usize, cotton_usb_host::usb_bus::UsbError>> {","highlight_start":10,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Future` is not implemented for `()`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `()` is not a future\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/host/controllers/mod.rs:82:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ) -> impl core::future::Future<Output = Result<usize, cotton_usb_host::usb_bus::UsbError>> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`()` is not a future\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Future` is not implemented for `()`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`()` is not a future","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/host/controllers/mod.rs","byte_start":2399,"byte_end":2484,"line_start":94,"line_end":94,"column_start":10,"column_end":95,"is_primary":true,"text":[{"text":"    ) -> impl core::future::Future<Output = Result<usize, cotton_usb_host::usb_bus::UsbError>> {","highlight_start":10,"highlight_end":95}],"label":"`()` is not a future","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/host/controllers/mod.rs","byte_start":2399,"byte_end":2484,"line_start":94,"line_end":94,"column_start":10,"column_end":95,"is_primary":false,"text":[{"text":"    ) -> impl core::future::Future<Output = Result<usize, cotton_usb_host::usb_bus::UsbError>> {","highlight_start":10,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Future` is not implemented for `()`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `()` is not a future\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/host/controllers/mod.rs:94:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m94\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ) -> impl core::future::Future<Output = Result<usize, cotton_usb_host::usb_bus::UsbError>> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`()` is not a future\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Future` is not implemented for `()`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`()` is not a future","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/host/controllers/mod.rs","byte_start":2759,"byte_end":2844,"line_start":106,"line_end":106,"column_start":10,"column_end":95,"is_primary":true,"text":[{"text":"    ) -> impl core::future::Future<Output = Result<usize, cotton_usb_host::usb_bus::UsbError>> {","highlight_start":10,"highlight_end":95}],"label":"`()` is not a future","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/host/controllers/mod.rs","byte_start":2759,"byte_end":2844,"line_start":106,"line_end":106,"column_start":10,"column_end":95,"is_primary":false,"text":[{"text":"    ) -> impl core::future::Future<Output = Result<usize, cotton_usb_host::usb_bus::UsbError>> {","highlight_start":10,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Future` is not implemented for `()`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `()` is not a future\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/host/controllers/mod.rs:106:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ) -> impl core::future::Future<Output = Result<usize, cotton_usb_host::usb_bus::UsbError>> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`()` is not a future\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Future` is not implemented for `()`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `rst`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/host/controllers/mod.rs","byte_start":1793,"byte_end":1796,"line_start":72,"line_end":72,"column_start":31,"column_end":34,"is_primary":true,"text":[{"text":"    fn reset_root_port(&self, rst: bool) {","highlight_start":31,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/host/controllers/mod.rs","byte_start":1793,"byte_end":1796,"line_start":72,"line_end":72,"column_start":31,"column_end":34,"is_primary":true,"text":[{"text":"    fn reset_root_port(&self, rst: bool) {","highlight_start":31,"highlight_end":34}],"label":null,"suggested_replacement":"_rst","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `rst`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/host/controllers/mod.rs:72:31\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn reset_root_port(&self, rst: bool) {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_rst`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 7 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 7 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0207, E0210, E0277.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0207, E0210, E0277.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0207`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0207`.\u001b[0m\n"}
